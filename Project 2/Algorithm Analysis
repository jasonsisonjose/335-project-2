  For MergeSort the running time we have multiple calls to helper functions and then two recursive calls that divide the input array
in half. The helper functions called inside the mergesort can be considered null since most of the time being consumed is from the
recursive calls that get called a maximum of the number of elements inside the array divided by two. This gives a bigO of O(N*log(N)).

  Poresortâ€™s running time creates some helper variables and goes into a two loops: the first a while loop and the second a for loop.
With this the while and for loop can iterate a total of n times. This gives Poresort a bigO of O(N^2).

  For QuickSort, the running time will utilize a helper function to start the recursive calls, where it splits the input array into two sections using a selected element as a pivot.
  Then the recursive calls will try to sort the left side until it can no longer sort the left side. Afterwards it will try to sort the right side until it
  can no longer sort the right side. Because of this it has a potential to have a worse case big O of O(N^2), but on overage because it is a divide and conquer algorithm, it has a big O of
  O(N*log(N).
  
